"""
Задача 28: Напишите рекурсивную функцию sum(a, b), возвращающую сумму двух целых неотрицательных чисел. 
Из всех арифметических операций допускаются только +1 и -1. Также нельзя использовать циклы.
2 2
4
"""


def summa(a, b):
    if a == 0:
        return b;
    return summa(a-1, b+1)

-----------------------------------------------------------------------------------------------------------------

"""
Задача 26: Напишите программу, которая на вход принимает два числа A и B, и возводит число А в целую степень B с помощью рекурсии.
A = 3; B = 5 -> 243 (3⁵)
A = 2; B = 3 -> 8
"""

ef power(base, exp):
    if (n == 0):
        return 1
    if (exp == 1):
        return (base)
    if (exp != 1):
        return (base * power(base, exp - 1))
base = int(input("Введите число: "))
exp = int(input("Введите его степень: "))
print("Результат возведения в степень равен:", power(base, exp))

-----------------------------------------------------------------------------------------------------------------
"""
Доп. Петя успевает по математике лучше всех в классе, поэтому учитель задал ему сложное домашнее задание, 
в котором нужно в заданном наборе целых чисел найти сумму всех положительных элементов, 
затем найти где в заданной последовательности находятся максимальный и минимальный элемент и вычислить произведение чисел, 
расположенных в этой последовательности между ними. Так же известно, 
что минимальный и максимальный элемент встречаются в заданном множестве чисел только один раз и не являются соседними. 
Поскольку задач такого рода учитель дал Пете около ста, то Петя как сильный программист смог написать программу, 
которая по заданному набору чисел самостоятельно находит решение. А Вам слабо?
"""

int main() {
    int n, mx = 0, mn = 0, sm = 0, pr = 1;
    cin >> n;
    vector <int> now(n);
    cin >> now[0];
    for (int i = 1; i < n; ++i) {
        cin >> now[i];
        if (now[i] > now[mx]) // было: now[i] > mx - я сравнивал элемент с индексом
            mx = i;
        if (now[i] < now[mn]) // было: now[i] < now[mn] - то же самое
            mn = i;
        if (now[i] > 0)
            sm += now[i];
    }
    for (int i = min(mn, mx) + 1; i < max(mx, mn); ++i)
        pr *= now[i];
    sm += now[0] > 0 ? now[0] : 0;
    cout << sm << " " << pr;

    return 0;
}